# -*- coding: utf-8 -*-
"""Projek_Uas_TSP_Dijkstra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BVKFEx-iJJBZBQZEPwdsju2m04x3Ucr5
"""

#Nurul Aliyah Dyah Sakhinah - F55121069

import sys
import time

# Algoritma Dijkstra
def dijkstra(graph, start, end):

    # Inisialisasi jarak awal
    distances = {vertex: sys.maxsize for vertex in graph}
    distances[start] = 0

    # Inisialisasi path awal
    path = {}

    # Simpan node yang belum dikunjungi
    unvisited_nodes = graph.copy()

    # Perulangan hingga semua node dikunjungi
    while unvisited_nodes:
        # Pilih node dengan jarak terpendek
        current_node = min(unvisited_nodes, key=lambda vertex: distances[vertex])

        # Periksa tetangga-tetangga yang belum dikunjungi
        for neighbor, weight in graph[current_node].items():
            if neighbor in unvisited_nodes:
                new_distance = distances[current_node] + weight
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    path[neighbor] = current_node

        # Tandai node saat ini sebagai dikunjungi
        unvisited_nodes.pop(current_node)

        # Jika sudah mencapai node tujuan, hentikan perulangan
        if current_node == end:
            break

    # Jika tidak ada jalur yang ditemukan ke node tujuan
    if distances[end] == sys.maxsize:
        return None, None

    # Bangun jalur terpendek dari node tujuan ke node awal
    shortest_path = []
    current_node = end
    while current_node != start:
        shortest_path.append(current_node)
        current_node = path[current_node]
    shortest_path.append(start)

    # Balikkan jalur terpendek dan jaraknya
    return shortest_path[::-1], distances[end]

# Algoritma TSP (Brute Force)
def tsp(graph, start, end):
    # Membangun daftar semua kemungkinan jalur
    def generate_paths(graph, start, end, path=[]):
        path = path + [start]
        if start == end:
            return [path]
        if start not in graph:
            return []
        paths = []
        for node in graph[start]:
            if node not in path:
                new_paths = generate_paths(graph, node, end, path)
                for new_path in new_paths:
                    paths.append(new_path)
        return paths

    # Menghitung total jarak dari suatu jalur
    def calculate_distance(graph, path):
        distance = 0
        for i in range(len(path) - 1):
            current_node = path[i]
            next_node = path[i + 1]
            distance += graph[current_node][next_node]
        return distance

    # Menghitung jalur terpendek dari semua kemungkinan jalur
    paths = generate_paths(graph, start, end)
    shortest_path = min(paths, key=lambda x: calculate_distance(graph, x))
    distance = calculate_distance(graph, shortest_path)

    return shortest_path, distance

# Menampilkan Graph
def print_graph(graph):
    for vertex in graph:
        print(vertex, "->", graph[vertex])

# Fungsi utama
def main():
    # Graph
    graph = {
        'a': {'b': 12, 'c': 10, 'g': 12},
        'b': {'a': 12, 'd': 12, 'c': 8},
        'c': {'a': 10, 'b': 8, 'd': 11, 'e': 3, 'g': 9},
        'g': {'a': 12, 'c': 9, 'e': 7, 'f': 9},
        'd': {'b': 12, 'c': 11, 'e': 11, 'f': 10},
        'e': {'c': 3, 'd': 11, 'g': 7, 'f': 6},
        'f': {'d': 10, 'e': 6, 'g': 9}
    }

    print("Grafik:")
    print_graph(graph)

    while True:
        start_node = 'a'
        end_node = 'f'

        # Pilihan algoritma dari user
        print("\nPilih algoritma:")
        print("1. TSP (Traveling Salesman Problem)")
        print("2. Dijkstra")
        algorithm_choice = int(input("Masukkan nomor algoritma: "))

        if algorithm_choice == 1:
            # Menghitung shortest path menggunakan algoritma TSP
            start_time = time.time()
            shortest_path, distance = tsp(graph, start_node, end_node)
            end_time = time.time()
            algorithm_name = "TSP (Traveling Salesman Problem)"
        elif algorithm_choice == 2:
            # Menghitung shortest path menggunakan algoritma Dijkstra
            start_time = time.time()
            shortest_path, distance = dijkstra(graph, start_node, end_node)
            end_time = time.time()
            algorithm_name = "Dijkstra"
        else:
            print("Pilihan algoritma tidak valid.")
            continue

        # Menampilkan hasil setiap iterasi
        print("\nHasil setiap iterasi:")
        for i, node in enumerate(shortest_path):
            print(f"Iterasi {i+1}: {node}")

        # Menampilkan waktu komputasi perhitungan path
        computation_time = end_time - start_time
        print(f"\nWaktu komputasi: {computation_time} detik")

        # Menampilkan hasil akhir (shortest path)
        print("\nHasil akhir:")
        print(f"Jalur terpendek: {' -> '.join(shortest_path)}")
        print(f"Jarak terpendek: {distance}")

        # Pilihan untuk memilih algoritma kembali
        repeat_choice = input("\nApakah ingin memilih algoritma kembali? (y/n): ")
        if repeat_choice.lower() != "y":
            break

# Menjalankan program utama
main()